# Business: This automatically creates an issue using a schedule/cron. 
# TODO: This is also an example of using matris
# TODO: Replace all instances of placeholder!!

# Per Github documentation "A matrix strategy lets you use variables in a single job definition to 
# automatically create multiple job runs that are based on the combinations of the variables. "

# TODO: Idea --> Create two different issues with different templates but on same schedule?
# TODO: Use github.event.schedule to get the precise cron expression that triggered the workflow
name: Schedule-Matrix Issue Creation 

on:
  schedule:
    - cron: '0 0 * * 3' # At 00:00, every month, every week, ONLY Wednesday (3)

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      template:
        description: "Issue Template"
        required: false
        type: choice
        options: 
          - placeholder_val1
          - placeholder_val2
      verbose:
        description: "Additional debug messages"
        required: false
        type: boolean
        default: false

jobs:
  create-sched-issue:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    env:
      TEMPLATE_USED: ${{ github.event.schedule }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    strategy:
      matrix:
        issue_template: ["schedule-generated-issue-template1.yml", "schedule-generated-issue-template2.yml"]
        # placeholder2: [1,2]
    steps:
      
      - name: Check out repository
        uses: actions/checkout@v4

      - name: "placeholder step"
        run: echo "placeholder step fired off"
      
      - name: Get Issue Template
        env:
          ISS_TEMP: "${{ matrix.issue_template }}"
        run: |
          echo "pwd:"
          pwd
          echo "This issue template (ISS_TEMP) for this job is $ISS_TEMP."
          echo "This step should get the issue template from above, and write its contents to env"
          template_text=$(cat .github/ISSUE_TEMPLATE/$ISS_TEMP)
          # In Bash, curly braces group a list of commands. << indicates a here-doc, which is used to redirect input
          # Everything after <<EOF is considered input until the next EOF is reached. EOF here is a placeholder term--you could use DOG, PACMAN, or some other word.
          # EOF is considered a delimiter. In our case we want the whole of the template to be written to the env var TEMPLATE
          # So we should use a delimiter that WON'T be present in the template--"EOF" isn't present in either of files in martix.issue_template
          # Github Actions will recognize << as you trying to assign whatever-named variable that is left of << (in our case, TEMPLATE) to a multiline value
          # Thus TEMPLATE takes all of the template text, and we write TEMPLATE to GITHUB_ENV via the standard '>> $GITHUB_ENV' syntax
          {
            echo "TEMPLATE<<EOF"            
            echo "${template_text}"
            echo "EOF"
          } >> $GITHUB_ENV


      - name: Create Issue Using Template
        run: |
          echo "About to make a new issue using an issue template (${{ matrix.issue_template }})."
          if [[ "${{ github.event.inputs.verbose }}" == "true" ]]
          then
            # The head commang gets the first X amt of lines (17). Tail gets the last X amt of lines (1).
            # So first would output the first 17 lines, use pipe to use this as input for tail --> tail looks at last line of the 17 lines (i.e. the 17th line in the var)
            first_line=$(echo "$TEMPLATE" | head -n 17 | tail -n 1)
            echo "17th line of the template:"
            echo "${first_line} !!!"
          fi
          TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")
          $TEMPLATE="${TEMPLATE//{{DATE}}/${TIMESTAMP}}"
          if [[ "${{ github.event.inputs.verbose }}" == "true" ]]
          then
            first_line=$(echo "$TEMPLATE" | head -n 18 | tail -n 1)
            echo "18th line of the template (shows timestamp):"
            echo "${first_line} !!!"
          fi