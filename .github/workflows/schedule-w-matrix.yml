# Business: This automatically creates an issue using a schedule/cron. 
# TODO: This is also an example of using matris
# TODO: Replace all instances of placeholder!!

# Per Github documentation "A matrix strategy lets you use variables in a single job definition to 
# automatically create multiple job runs that are based on the combinations of the variables. "

# TODO: Idea --> Create two different issues with different templates but on same schedule?
# TODO: Use github.event.schedule to get the precise cron expression that triggered the workflow
name: Schedule-Matrix Issue Creation 

on:
  schedule:
    - cron: '0 0 * * 3' # At 00:00, every month, every week, ONLY Wednesday (3)

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      template:
        description: "Issue Template"
        required: false
        type: choice
        options: 
          - placeholder_val1
          - placeholder_val2
      verbose:
        description: "Additional debug messages"
        required: false
        type: boolean
        #TODO: Turn this to false once initial testing complete
        default: true

jobs:
  create-sched-issue:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      # contents: write ??? For issue template stuff. See https://docs.github.com/en/rest/issues/issues?apiVersion=2022-11-28#create-an-issue
    env:
      TEMPLATE_USED: ${{ github.event.schedule }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    strategy:
      matrix:
        # "do-not-use" does not point to an issue template. It's present here for testing purposes (TODO list purposes)
        issue_template: ["schedule-generated-issue-template1.yml", "schedule-generated-issue-template2.yml", "do-not-use", "do-not-use-2"]
        # placeholder2: [1,2]
        exclude: 
          - issue_template: "do-not-use"
    steps:
      
      - name: Check out repository
        uses: actions/checkout@v4

      - name: "placeholder step"
        run: echo "placeholder step fired off"
      
      - name: Get Issue Template
        env:
          ISS_TEMP: "${{ matrix.issue_template }}"
        run: |
          echo "pwd:"
          pwd
          
          if [[ "${{ matrix.issue_template }}" == "do-not-use" ]]
          then
            echo "For now (11-15-2025), the 'do-not-use' matrix template option should just fail if it's encountered. Failing this job."
            exit 1
          fi
          echo "github.event = ${{ github.event }}"
          
          if [[ "${{ github.event }}"  == "workflow_dispatch" && "${{ matrix.issue_template }}" == "do-not-use-2" ]]
          then
            echo "This job uses 'do-not-use-2' as a value for matrix.issue_template. This doesn't point to a valid template."
            echo "This shouldn't be activated when fired off by a schedule."
            template_text="do-not-use-2"
            echo"TEMPLATE=$template_text" >> $GITHUB_ENV
          else  
            echo "This issue template (ISS_TEMP) for this job is $ISS_TEMP."
            echo "This step should get the issue template from above, and write its contents to env"
            template_text=$(cat .github/ISSUE_TEMPLATE/$ISS_TEMP)
            
            # In Bash, curly braces group a list of commands. << indicates a here-doc, which is used to redirect input
            # Everything after <<EOF is considered input until the next EOF is reached. EOF here is a placeholder term--you could use DOG, PACMAN, or some other word.
            # EOF is considered a delimiter. In our case we want the whole of the template to be written to the env var TEMPLATE
            # So we should use a delimiter that WON'T be present in the template--"EOF" isn't present in either of files in martix.issue_template
            # Github Actions will recognize << as you trying to assign whatever-named variable that is left of << (in our case, TEMPLATE) to a multiline value
            # Thus TEMPLATE takes all of the template text, and we write TEMPLATE to GITHUB_ENV via the standard '>> $GITHUB_ENV' syntax
            {
              echo "TEMPLATE<<EOF"            
              echo "${template_text}"
              echo "EOF"
              } >> $GITHUB_ENV
          fi
              

      - name: Create Issue Using Template
        run: |
          echo "About to make a new issue using an issue template (${{ matrix.issue_template }})."

          if [[ "$TEMPLATE" == "do-not-use-2" ]]
          then
            echo "TEMPLATE = '$TEMPLATE' NOT doing any issue template stuff."
          else
            if [[ "${{ github.event.inputs.verbose }}" == "true" ]]
            then
              # The head commang gets the first X amt of lines (17). Tail gets the last X amt of lines (1).
              # So first would output the first 17 lines, use pipe to use this as input for tail --> tail looks at last line of the 17 lines (i.e. the 17th line in the var)
              first_line=$(echo "$TEMPLATE" | head -n 17 | tail -n 1)
              echo "17th line of the template:"
              echo "${first_line} !!!"
            fi
            
            timestamp=$(date +"%Y-%m-%d %H:%M:%S")
            date_placeholder="{{DATE}}"
            TEMPLATE="${TEMPLATE//${date_placeholder}/${timestamp}}"
            
            if [[ "${{ github.event.inputs.verbose }}" == "true" ]]
            then
              first_line=$(echo "$TEMPLATE" | head -n 18 | tail -n 1)
              echo "18th line of the template (shows timestamp):"
              echo "${first_line} !!!"
            fi
            
            # Template extraction
            
            # (?<=type:).* = Use positive lookbehind to match a pattern ONLY if it is preceded by another pattern. So we want everything (.*) after "type"
            # -m1 = first match, -P = enable Perl-regex, -o = only return what the regex matches, not the whole line
            title_text=$(echo "$TEMPLATE" | grep -m1 -P -o '(?<=title: ).*' | tr -d '"')
            echo "title_text = ${title_text}"
            
            description_text=$(echo "$TEMPLATE" | grep -m1 -P -o '(?<=description: ).*' | tr -d '"')
            echo "description_text = ${description_text}"
            
            labels_text=$(echo "$TEMPLATE" | grep -m1 -P -o '(?<=labels: ).*' | tr -d '"[]' )
            echo "labels_text = ${labels_text}" # "["something"]"
            
            # Use first sed (stream editor) to find line that matches 'body:', then print that line and everything after ($p)
            # sed prints every line automatically. So use -n to prevent that behavior. (Otherwise you'd be printing "body:" "body:", etc.) 
            # When you use -n, you must tell sed what to print. So use $p to say "print this line and everything after it"
            # Use second sed to delete (d) the first line (1) from that. These commands combine to '1d'
            body_text=$(echo "$TEMPLATE" | sed -n '/body:/,$p' | sed '1d')
            echo "body_text = ${body_text}" 
            
            # echo "$TEMPLATE"
            
            # Only get the first match (-m1) because other types will be present in the YAML
            type_text=$(echo "$TEMPLATE" | grep -m1 -P -o '(?<=type: ).*')
            if [[ "$type_text" == "markdown" || "$type_text" == "input" || "$type_text" == "textarea" || "$type_text" == "dropdown" || "$type_text" == "checkboxes" ]]
            then
              # Don't include the type as an arg in the call
              echo "Not including 'type' in call to the Github API 'issue create' endpoint since the first 'type' key encountered was '${type_text}'"
            else
              echo "!!! ${type_text}"
            fi
            
            # gh issue create --title "My new issue title" --body "Detailed description of the issue."
            
            #TODO: incorporate type key conditional logic above
            # gh api \
            #   --method POST \
            #   -H "Accept: application/vnd.github+json" \
            #   -H "X-GitHub-Api-Version: 2022-11-28" \
            #   /repos/org-mushroom-kingdom/bash-git-script/issues \
            #   --input - <<< '{
            #   "title": "$title_text",
            #   "body": "$body_text",
            #   "type": "$type_text"
            #   "labels": [
            #     "$label_text"
            #   ]
            # }
          fi
